---
layout: post
title: 爬楼梯
categories: ACM
---

> NEUOJ  
> 2017.4.22--2017年新生组队赛   

<!-- more -->

__Link: [https://oj.neu.edu.cn/problem/1151](https://oj.neu.edu.cn/problem/1151)__  

### Problem Description
小时候，我只能一阶一阶得爬楼梯，  
后来，我除了能一次爬一阶，还可以一次爬两阶，  
到现在，我最多一次可以爬三阶。  
那么现在问题来了，我想爬上n层楼，相邻楼层之间有一段楼梯，虽然我一次可以爬1个台阶、2个台阶和3个台阶，但是我在i与i+1层之间的楼梯上时，我不能跨越到i+1与i+2层之间的楼梯。现在有个n层的楼，知道每一段楼梯的阶数，我想知道，如果我只会往上走，并且忽略其他不在楼梯上的其他移动，共有多少种方案可以到达第n层。  

### Input
第一行一个整数T（0\<T\<=50）表示有多少组样例。  
对于每一组样例：  
第一行一个n（1\<n\<=50）表示有多少层楼。  
接下来一行，包括n-1个整数xi（0\<xi\<=20），由下到上依次表示每段楼梯的长度。  

### Output
对于每组数据，输出一行表示共有多少种方案。由于答案较大，所以输出答案请对10007取模。  

### Sample Input
2  
2  
3  
4  
4 5 6  

### Sample Output
4  
2184  

<hr/>

### 分析
这道题是一个简单的动态规划。  
先分别求出上一，二，三阶的方法数：  
a[1] = 1;  
a[2] = 2;  
a[3] = 4;  
然后四阶就可以分解为三阶+一阶，二阶+二阶，一阶+三阶，a[4] = a[3] + a[2] + a[1];  
然后五阶就可以分解为四阶+一阶，三阶+二阶，二阶+三阶，a[5] = a[4] + a[3] + a[2];  
即a[i] = a[i - 1] + a[i - 2] + a[i - 3]。  

### 代码
{% highlight c++ %}
#include<cstdio>

int main(void)
{
    int t, n, x, i, ans;
    int a[25];
    a[0] = 1;
    a[1] = 1;
    a[2] = 2;
    for(i = 3;i < 25;i++)
        a[i] = a[i - 1] + a[i - 2] + a[i - 3];
    while(scanf("%d", &t) != EOF)
    {
        while(t--)
        {
            scanf("%d", &n);
            ans = 1;
            while(--n)
            {
                scanf("%d", &x);
                ans *= a[x];
                ans %= 10007;
            }
            printf("%d\n", ans);
        }
    }
    return 0;
}
{% endhighlight %}
