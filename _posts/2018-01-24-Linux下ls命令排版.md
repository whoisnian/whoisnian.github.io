---
layout: post
title: Linux下ls命令排版
categories: Programming
---

> 想用C语言模拟一下ls命令的效果，想了几种默认情况下的排版以及实现，感觉都不太满意，于是就好奇地去看了一下ls的源码。  

<!-- more -->

Google 得到 ls 一类的基础命令属于 coreutils 的一部分，然后在[http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/ls.c](http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/ls.c)找到了ls的源代码。  
接着找到了其中的`calculate_columns`函数，具体的实现代码从第[5068](http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/ls.c#n5068)行开始，看起来不是太多，就尝试着阅读了一下。  
{% highlight c %}
/* Calculate the number of columns needed to represent the current set
   of files in the current display width.  */

static size_t
calculate_columns (bool by_columns)
{
  size_t filesno;		/* Index into cwd_file.  */
  size_t cols;			/* Number of files across.  */

  /* Normally the maximum number of columns is determined by the
     screen width.  But if few files are available this might limit it
     as well.  */
  size_t max_cols = MIN (max_idx, cwd_n_used);

  init_column_info ();

  /* Compute the maximum number of possible columns.  */
  for (filesno = 0; filesno < cwd_n_used; ++filesno)
    {
      struct fileinfo const *f = sorted_file[filesno];
      size_t name_length = length_of_file_name_and_frills (f);

      for (size_t i = 0; i < max_cols; ++i)
        {
          if (column_info[i].valid_len)
            {
              size_t idx = (by_columns
                            ? filesno / ((cwd_n_used + i) / (i + 1))
                            : filesno % (i + 1));
              size_t real_length = name_length + (idx == i ? 0 : 2);

              if (column_info[i].col_arr[idx] < real_length)
                {
                  column_info[i].line_len += (real_length
                                              - column_info[i].col_arr[idx]);
                  column_info[i].col_arr[idx] = real_length;
                  column_info[i].valid_len = (column_info[i].line_len
                                              < line_length);
                }
            }
        }
    }

  /* Find maximum allowed columns.  */
  for (cols = max_cols; 1 < cols; --cols)
    {
      if (column_info[cols - 1].valid_len)
        break;
    }

  return cols;
}
{% endhighlight %}

其中涉及到了几个前面的变量，比较重要的有以下几个：  
* `cwd_n_used`  
  ```c
  /* Index of first unused slot in 'cwd_file'.  */
  static size_t cwd_n_used;
  ```
  cwd 应该是指当前工作目录（current working directory），这里 cwd_n_used 是 cwd_file 中已使用的数目，也就是指要打印的目录下一共有多少文件和文件夹。  
* `max_idx`  
  ```c
  /* Maximum number of columns ever possible for this display.  */
  static size_t max_idx;
  ```
  当前显示区域能够放下的理论最大列数，可以找到它的初始值设置：  
  ```c
  /* The minimum width of a column is 3: 1 character for the name and 2
     for the separating white space.  */
  #define MIN_COLUMN_WIDTH	3

  /* Determine the max possible number of display columns.  */
  max_idx = line_length / MIN_COLUMN_WIDTH;
  /* Account for first display column not having a separator,
     or line_lengths shorter than MIN_COLUMN_WIDTH.  */
  max_idx += line_length % MIN_COLUMN_WIDTH != 0;
  ```
  这里是假设了所有文件的文件名只有一个字符，然后两列之间隔两个空格，依此计算显示区域可以放下的理论最大列数。  
* `column_info`  
  ```c
  /* Array with information about column filledness.  */
  static struct column_info *column_info;
  ```
  指向列信息数组的结构体指针，column_info[i] 中存储当总列数为i时的列相关信息。结构体包含：    
  ```c
  /* Information about filling a column.  */
  struct column_info
  {
    bool valid_len; //所有列的总宽度是否合法
    size_t line_len; //所有列的总宽度
    size_t *col_arr; //保存各列宽度的数组
  };
  ```

从函数整体流程来看，先设置最大列数（max_cols）为理论最大列数（max_idx）和总文件数（cwd_n_used）中的较小值，当文件名可以在一行内全部显示时可以减少计算量。  
然后遍历所有文件，对于每个文件（filesno），从总列数为0遍历到总列数为最大列数，当总列数为 i 时，计算该文件所在列（idx），并更新列数信息（column_info）中总列数为 i 时的情况（column_info[i]）。  
最后在列数信息（column_info）中从大到小遍历，找到列总宽度合法（valid_len）的列。当列数最大时，行数自然就最小了。  

emmmm，感觉有点暴力，每次都要尝试计算所有的可能排版方法。我觉得可以直接把总列数从大到小的循环放在外层，然后循环所有文件看列的总宽度是否合法，合法时直接跳出循环，不知道会不会好一点。  
